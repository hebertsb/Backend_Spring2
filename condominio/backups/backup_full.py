import os
import shutil
from datetime import datetime
from pathlib import Path
import subprocess
import zipfile
import argparse
import sys

# ---------------------------
# Configuraci√≥n de rutas
# ---------------------------

# Ra√≠z del proyecto (donde est√° manage.py y db.sqlite3)
PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent

# Carpeta de backups (√∫nica, dentro de condominio/backups)
BACKUP_ROOT = PROJECT_ROOT / "condominio" / "backups"

# Base de datos SQLite
SQLITE_FILE = PROJECT_ROOT / "db.sqlite3"

# Archivo manage.py
MANAGE_PY = PROJECT_ROOT / "manage.py"

# ---------------------------
# Funci√≥n de backup
# ---------------------------

def run_backup(include_backend=True, include_db=True, include_frontend=True, db_type="sqlite"):
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    temp_backup_dir = BACKUP_ROOT / f"backup_temp_{timestamp}"
    os.makedirs(temp_backup_dir, exist_ok=True)

    print(f"üì¶ Creando backup temporal en: {temp_backup_dir}")

    # -------------------
    # Backup de base de datos
    # -------------------
    if include_db:
        if db_type.lower() == "sqlite":
            if SQLITE_FILE.exists():
                shutil.copy(SQLITE_FILE, temp_backup_dir / SQLITE_FILE.name)
                print(f"üóÑÔ∏è Base de datos SQLite copiada: {SQLITE_FILE.name}")
            else:
                print("‚ö†Ô∏è No se encontr√≥ archivo de base de datos SQLite.")
        elif db_type.lower() == "postgres":
            pg_dump_file = temp_backup_dir / f"postgres_dump_{timestamp}.sql"
            print("üíæ Realizando backup de Postgres...")
            result = subprocess.run([
                "pg_dump",
                "-U", os.getenv("POSTGRES_USER", "postgres"),
                "-h", os.getenv("POSTGRES_HOST", "localhost"),
                "-p", os.getenv("POSTGRES_PORT", "5432"),
                "-F", "c",
                "-f", str(pg_dump_file),
                os.getenv("POSTGRES_DB", "mydatabase")
            ])
            if result.returncode == 0:
                print(f"‚úÖ Dump de Postgres generado: {pg_dump_file.name}")
            else:
                print("‚ùå Error al realizar backup de Postgres.")

    # -------------------
    # Backup de backend
    # -------------------
    if include_backend:
        include_dirs = ["condominio", "core", "authz", "config", "scripts"]
        exclude_patterns = ['venv', '__pycache__', 'backups', 'node_modules']

        backend_backup_dir = temp_backup_dir / "backend_code"
        os.makedirs(backend_backup_dir, exist_ok=True)

        print("üìù Copiando c√≥digo backend completo...")
        for include_dir in include_dirs:
            src = PROJECT_ROOT / include_dir
            if not src.exists():
                continue
            dst = backend_backup_dir / include_dir
            shutil.copytree(src, dst, ignore=shutil.ignore_patterns(*exclude_patterns))
        print("‚úÖ C√≥digo backend copiado correctamente.")

    # -------------------
    # Backup de datos JSON (fixtures)
    # -------------------
    if include_db and db_type.lower() == "sqlite":
        if MANAGE_PY.exists():
            json_backup_file = temp_backup_dir / f"dump_{timestamp}.json"
            subprocess.run([
                sys.executable, str(MANAGE_PY), "dumpdata",
                "--exclude", "auth.permission",
                "--exclude", "contenttypes",
                "--indent", "2",
                "--output", str(json_backup_file)
            ])
            print(f"üßæ Fixture JSON generada: {json_backup_file.name}")
        else:
            print("‚ö†Ô∏è No se encontr√≥ manage.py, no se pudo generar fixture JSON.")

    # -------------------
    # Comprimir todo en ZIP
    # -------------------
    zip_file = BACKUP_ROOT / f"full_backup_{timestamp}.zip"
    print(f"üìÅ Comprimiendo backup final en: {zip_file}")
    with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(temp_backup_dir):
            for file in files:
                file_path = Path(root) / file
                zipf.write(file_path, file_path.relative_to(temp_backup_dir))
    print(f"‚úÖ Backup completo comprimido en: {zip_file}")

    # Limpiar carpeta temporal
    shutil.rmtree(temp_backup_dir)
    print("üßπ Carpeta temporal eliminada. Backup finalizado con √©xito.")

# ---------------------------
# Ejecuci√≥n desde CLI
# ---------------------------

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Backup Django completo")
    parser.add_argument("--no-backend", action="store_true", help="No incluir c√≥digo backend")
    parser.add_argument("--no-db", action="store_true", help="No incluir base de datos")
    parser.add_argument("--no-frontend", action="store_true", help="No incluir frontend (solo si existe)")
    parser.add_argument("--db-type", choices=["sqlite", "postgres"], default="sqlite", help="Tipo de base de datos")
    args = parser.parse_args()

    run_backup(
        include_backend=not args.no_backend,
        include_db=not args.no_db,
        include_frontend=not args.no_frontend,
        db_type=args.db_type
    )
